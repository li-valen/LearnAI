<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Object Detection with Background Blur</title>
  <link rel="stylesheet" href="styles.css">
</head>

<style>
  #videoContainer {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(255, 255, 255, 0.5); /* Semi-transparent white background */
  backdrop-filter: blur(10px); /* Apply a blur filter */
  display: none; /* Initially hide the container */
}

#video {
  display: none; /* Hide the video element */
}

</style>
<body>

<!-- Start button -->
<button id="startButton">Start Object Detection</button>

<!-- Video and Canvas elements -->
<video id="video" autoplay></video>
<canvas id="canvas"></canvas>

<!-- Video container for background blur -->
<div id="videoContainer"></div>

<!-- Load script after HTML content to ensure DOM elements are loaded -->
<script>
let videoStream;

// Load the COCO-SSD model
async function loadModel() {
  const model = await cocoSsd.load();
  return model;
}

// Function to perform object detection on each frame of the video
async function detectObjects(video, model) {
  // Get the video element and canvas element
  const videoElement = document.getElementById('video');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  // Set canvas size to match video size
  canvas.width = videoElement.width;
  canvas.height = videoElement.height;

  // Perform object detection on each frame
  async function detectFrame() {
    const predictions = await model.detect(videoElement);

    // Clear previous drawings
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw bounding boxes around detected objects
    predictions.forEach(prediction => {
      ctx.beginPath();
      ctx.rect(...prediction.bbox);
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'red';
      ctx.fillStyle = 'red';
      ctx.stroke();
      ctx.fillText(`${prediction.class} (${Math.round(prediction.score * 100)}%)`, prediction.bbox[0], prediction.bbox[1] > 10 ? prediction.bbox[1] - 5 : 10);
    });

    requestAnimationFrame(detectFrame);
  }

  // Start object detection
  detectFrame();
}

// Function to start the camera and apply background blur
async function startCamera() {
  // Show the video container with background blur
  document.getElementById('videoContainer').style.display = 'block';

  // Get the video element
  const video = document.getElementById('video');

  try {
    // Get webcam stream
    videoStream = await navigator.mediaDevices.getUserMedia({ video: true });

    // Once the webcam stream is obtained, set it as the video source
    video.srcObject = videoStream;

    // Once the video stream is loaded, start object detection
    video.onloadedmetadata = async function(e) {
      const model = await loadModel();
      detectObjects(video, model);
    };
  } catch (err) {
    console.log("Error accessing webcam: " + err);
  }
}

// Function to stop the camera
function stopCamera() {
  if (videoStream) {
    const tracks = videoStream.getTracks();
    tracks.forEach(track => track.stop());
  }

  // Hide the video container
  document.getElementById('videoContainer').style.display = 'none';
}

// Event listener for the start button
document.getElementById('startButton').addEventListener('click', startCamera);

</script>

</body>
</html>
